grammar;

use crate::frontend::ast::*;

// Lexical
match {
    r"\s*" => {}, // skip whitespace
    r"//[^\n\r]*[\n\r]*" => {}, // skip single-line comment
    r"/\*([^*]|\*[^/])*\*/" => {}, // skip multi-line comment
    _
}

// Syntax
pub CompUnit: CompUnit = <func_def: FuncDef> => CompUnit { <> };

FuncDef: FuncDef = {
    <func_type: FuncType> <ident: Ident> "(" ")" <block: Block> => {
        FuncDef { <> }
    }
}

FuncType: FuncType = "int" => FuncType::Int;

Block: Block = "{" <stmt: Stmt> "}" => Block { <> };

Stmt: Stmt = "return" <expr: Exp> ";" => Stmt { <> };

// Exp ::= LOrExp; At Lv 3.3
Exp: Expr = {
    <lor: LOrExp> => lor,
}

PrimaryExp: Expr = {
    "(" <expr: Exp> ")" => expr,
    <num: Number> => Expr::Num(num),
}

UnaryExp: Expr = {
    <primary: PrimaryExp> => primary,
    "+" <unary: UnaryExp> => Expr::Pos(Box::new(unary)),
    "-" <unary: UnaryExp> => Expr::Neg(Box::new(unary)),
    "!" <unary: UnaryExp> => Expr::Not(Box::new(unary)),
}

// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
MulExp: Expr = {
    <unary: UnaryExp> => unary,
    <lhs: MulExp> "*" <rhs: UnaryExp> => Expr::Mul(Box::new(lhs), Box::new(rhs)),
    <lhs: MulExp> "/" <rhs: UnaryExp> => Expr::Div(Box::new(lhs), Box::new(rhs)),
    <lhs: MulExp> "%" <rhs: UnaryExp> => Expr::Mod(Box::new(lhs), Box::new(rhs)),
}

// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
AddExp: Expr = {
    <mul: MulExp> => mul,
    <lhs: AddExp> "+" <rhs: MulExp> => Expr::Add(Box::new(lhs), Box::new(rhs)),
    <lhs: AddExp> "-" <rhs: MulExp> => Expr::Sub(Box::new(lhs), Box::new(rhs)),
}

// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Expr = {
    <add: AddExp> => add,
    <lhs: RelExp> "<" <rhs: AddExp> => Expr::Lt(Box::new(lhs), Box::new(rhs)),
    <lhs: RelExp> ">" <rhs: AddExp> => Expr::Gt(Box::new(lhs), Box::new(rhs)),
    <lhs: RelExp> "<=" <rhs: AddExp> => Expr::Le(Box::new(lhs), Box::new(rhs)),
    <lhs: RelExp> ">=" <rhs: AddExp> => Expr::Ge(Box::new(lhs), Box::new(rhs)),
}

// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Expr = {
    <rel: RelExp> => rel,
    <lhs: EqExp> "==" <rhs: RelExp> => Expr::Eq(Box::new(lhs), Box::new(rhs)),
    <lhs: EqExp> "!=" <rhs: RelExp> => Expr::Ne(Box::new(lhs), Box::new(rhs)),
}

// LAndExp ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Expr = {
    <eq: EqExp> => eq,
    <lhs: LAndExp> "&&" <rhs: EqExp> => Expr::Land(Box::new(lhs), Box::new(rhs)),
}

// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Expr = {
    <land: LAndExp> => land,
    <lhs: LOrExp> "||" <rhs: LAndExp> => Expr::Lor(Box::new(lhs), Box::new(rhs)),
}

// `<>` stands for the matched string
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

Number: i32 = <IntConst>;

// Integer Literal
IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}